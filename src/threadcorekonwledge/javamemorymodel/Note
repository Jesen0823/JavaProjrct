一，辨析三个概念
1.Java内存模型JMM
和并发有关

2.JVM内存结构
和Java虚拟机的运行区域有关，堆，栈
class文件经过类加载器，运行时数据区包含各线程共享的方法区和堆，各个线程私有的栈，本地方法栈，程序计数器
堆占用内存最多，主要是new创建的实例对象和数组，特点是动态分配
对象的引用保存在栈，编译时候就确定了大小，不会改变
方法区是共享的，主要存储已经加载的静态变量，常量，包含永久引用
本地方法栈，保存本地方法即native方法
程序计数器保存字节码指令行号，分支，循环和异常处理

3.Java对象模型
对象是有结构的，方法区和栈结构；
方法区创建类的信息，保存instanceKlass
堆，每一个实例对象会放入堆，每个实例有对象头和实例数据
对象的引用会保存在对象的堆中
java对象在虚拟机中的表现形式
二，什么是JMM
是一种规范。不同平台处理器不一样，无法保证并发安全，需要一种标准规范保证并发安全
规范使得JVM,程序，处理器cpu共同遵守，保证不同平台的JVM重排序后，不同虚拟机上的结果安全可靠可预期，
volatile,synchronized,Lock的原理都是JMM,使得开发者更容易处理并发问题

三，happen-before规则有哪些？后运行的能看到先运行的
1.单线程操作(不影响重排序，跟重排序无关)
2.锁操作（synchronized，Lock）
3.volatile
4.线程启动
5.线程join
6.传递性 可见性一行一行传递
7.中断
8.构造方法
9.并发工具类，如：1)线程安全的容器2)CountDownLatch,3)Semaphore,4)Future,5)线程池，6)CyclicBarrier


volatile synchronized

四，可见性
1)什么是可见性
一个线程修改了数据，另一个线程只看到了一半

2)为什么会出现可见性
每一个核心都有一个独占内存，两个线程在不同的核心运行，本地内存之间通讯只能通过主内存，此时独占内存的修改还没同步到主内存

3)主内存和本地内存
为了提高cpu速度，主内存到核心独占内存之间是有多级缓存的，最接近cpu的是寄存器
主内存和本地内存是jmm的抽象概念，是对寄存器，一级缓存，二级缓存的抽象，相当于把多级复杂缓存抽象成了两层
既保证了cpu效率，又方便了开发程序
JMM有以下规定，每个变量都是存在主内存的，本地内存读取的是主内存中的副本，主内存是共享的，不共享本地内存
线程间共享数据是通过本地内存交换的，而交换不一定是实时的，这就造成了可见性问题

4)happens-before原则
保证可见性问题，如果一个操作happens-before另一个操作，就说该修改是线程可见的

5)volatile
会强制把本地内存的数据刷到主内存
作用：可见性，禁止重排序
一种同步机制，比synchronized和Lock更轻量，因为volatile不会发生上下文切换这样开销很大的行为
但是开销小，能力也小，但是做不到像synchronized那样的原子同步。
可见性):
读取一个volatile变量之前，会先使本地缓存失效，这样就必须到主内存读取最新值，写一个volatile变量会立即刷入主内存
这样就保证了线程之前的可见性
禁止重排序):
禁止指令重排序优化，解决单例双重锁乱序问题

A.不适用的场景:
比如 a++操作
B.适用的场合1：
类似boolean flag这样,如果一个变量自始至终都被各个线程赋值而没有其他的操作，
不依赖变量之前的值，那就可以用volatile代替synchronized或者原子变量操作
C.适用的场合1：
刷新之前变量的触发器


6)保证可见性的措施
volatile,synchronized,Lock,并发集合，Thread.join(),Thread.start()
都可以保证可见性

7)对synchronized的理解

五，重排序
代码指令执行顺序和在java代码中的顺序不一样，就是说发生了重排序
重排序堆代码的指令做了优化
编译器重排优化，通过乱序提高效率，还有cup对指令重排序。引出了可见性问题
六，原子性
1.什么是原子性？
一系列操作要么全部成功，要么全部不成功，是不可分割性的，这就是原子性。

2.Java哪些操作是原子性的
1)除long,double外的基本类型的赋值操作
2）所有引用的赋值操作
3）工具类java.concurrent.Atomic.*中所有工具

3.long和double的原子性
出于java存储器模型的目的，64位的值，会分两次32位写入
在32位的机器上会分两次，出现不同步的情况，64位上是同步的
理论建议通过加volatile关键字处理
实际开发中，商用虚拟机已经考虑处理过了，并不需要额外加volatile

4.原子操作+原子操作 ！= 原子操作

七，面试问题
1.单例模式8种写法
单例的好处：只有一个对象，节省内存和计算节省资源，方便管理
适用单例的场景：1）无状态的工具类如日志管理。2）全局类信息
对比：
1）饿汉，简单，但是没有lazy-loading懒加载，浪费内存
2）懒汉，有线程安全问题
3）静态内部类，可以用
4）双重检查，可以用
5）枚举类，推荐用

2.volatile synchronized的异同？
volatile可以看作轻量级的synchronized，
volatile操作是无锁的，没提供原子性和互斥性，它不能完全代替synchronized,
因为无锁，不会花时间在获取锁和释放锁上，且不存在上下文切换的开销，所以它是低成本的。
volatile只能作用于属性，修饰属性后，就不会对这个属性做指令重排序了。

synchronized不仅保证了原子性，也保证了可见性
synchronized也有近朱者赤特点，第二个线程拿到锁的时候，能看到第一个线程解锁时候和解锁之前的操作


八，自顶向下学习方法
《计算机网络 自顶向下法》